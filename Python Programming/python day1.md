# Python Programming Day1

1. 파이썬 프로그래밍 개발환경  
<hr/>  

* 파이썬 버전은 3.x.x 이런 포맷으로 되어있다. 2.x.x와는 API가 전부 바뀌었기 때문에 서로간의 호환이 안된다. 3.x.x 끼리는 호환이 가능하다. 이들은 버그 수정 본의 최신판에 따라 버전이 올라간다.  

* jupyter notebook의 경우는 구현하기에 알맞다. 도커 이미지를 그대로 다운받아서 쓰기에도 용이하다.  

* 교수님은 vscode를 사용한다.  

* 되도록 최신 버전을 설치하고 add python path를 해야 pip 등 실행에 필요하다.  
      
* interpretor를 수행하는 언어는 bash, basic 등이 있다. 파이썬도 거의 interpretor의 역할을 하는 것이다. 파이썬과 C의 중간에 있는 것이 자바이다. 컴파일하는 프로그램은 실행을 자기 자신이 스스로 한다. 자바는 자바 버추얼 머신에서 컴파일한 코드를 excusion 하는 것이다. 파이썬은 .py로 끝난다. idle이 우리가 짠 프로그램을 line by line으로 읽으면서 수행한다.
  
* compling approach는 스스로 돌아가야하기 때문에 다 집어넣어야한다. .exe를 생성하면 스스로 돌아가는 것이 그 예이다. 이것을 static binding이라고 한다. 그 반대로 dynamic binding 이 있다. 인풋이 들어오면 순간 라이브러리를 가져와서 수행한다. 파이썬의 경우 pi.py라는 사이트에서 온라인으로 가져온다.  

* 에러를 그대로 긁어서 **구글에 친다**.  
  
* idle 파이썬 라이브러리를 업데이트 하기 위해 프로젝트를 시작하기 전에 pip install -upgrade pip를 한다.  
  
2. 변수와 자료형  
<hr/>  

* 어떤 언어라도 시작은 assignment statement이다. a = 3 같은 것 말이다. 두 번째는 if나 else로 시작하는 conditional statement 이다. 세 번째는 for나 while을 이용하는 반복문이다. 네 번째는 io statement이다. 프로그래밍 언어마다 조금 다르지만 앞의 세개는 거의 비슷하다.  
  
* 값을 저장하는 장소가 있어야한다. 그 장소를 우리는 **변수**라고 한다. 수학과는 달리 저장한다는 의미가 강하다. 정확하게는 값을 저장하는 메모리 공간에 대한 tag이다.  
  
* **변수 이름 = 값** 이런 형태가 할당문이다. 왼쪽에는 항상 variable, 오른쪽에는 값이 와야한다. python의 특징은 자료형을 선언하지 않아도 된다. 오른쪽에는 계산 결과라던지, 변수간의 계산 식이 할당될수 있다.
  
* 변수 이름을 지을 때 알파벳으로 시작하고 나머지는 알파벳, 숫자, 언더바 등을 이용하여 하는 것이 좋다. '-'는 쓰면 안된다. 연산자이기 때문이다. <span style ='color:grey'>네이버나 구글에 파이썬 네이밍에 대해 참조를 얻어도 좋다.</span> git에 가서 파이썬 프로그래밍에 대해 공부를 해보면 스타일이 닮아진다.  
  
* variable의 type은 언제 정해지냐면 assign 될 때 정해진다. 파이썬은 9가지의 자료형(int, float, complex, bool, str, list, tuple, set, dict)을 지원한다. mutable 자료형은 값을 변경할 수 있는 자료형(list, set, dict)이고 immutable 자료형은 값을 변경할 수 없는 자료형이다. 재료를 하나씩 꺼내서 확인할 수 있는 자료형을 iterable 자료형(list, set, tuple, dict)이라고 한다.  
  
* 문자열이라는 것은 immutable이다.  
    ``` python
    >>> a = "hala python!"
    >>> type(a) = str
    #type은 인풋의 자료형이 아닌 가르키는 객체의 자료형을 반환한는 함수이다.
    ```
* int(), float(), str() 등의 함수로 자료형을 변환할 수 있다.  

* expression = Term+/-Expression이다. 이 때 Term은 Term (*, /, **) expression이 될 수 있다. 따라서 Term만 덜렁 남는다면 a = 3 이 되는 것이다.  

* 수식의 우선 순위는 우리가 하는 산술과정과 동일하다.  
  
* 복합연산자를 적용할 수도 있다. <span style="color:red">되도록 사용하지 말자. 헷갈린다.</span>  

* input()함수는 리턴할 때 까지의 입력을 문자열로 변수에 할당하는 것이다. <span style="color:red">숫자도 집언허으면 변수에 str로 저장된다.</span>  
  
* variable과 str을 결합할 때 blank를 집어넣는다.
    ``` python
    input(age)
    print("내 나이는", age, "입니다.")
    #결과 : 내 나이는 20 입니다.
    ```

3. 기본 문자열과 입출력 처리  
<hr/>  
  
* 문자열은 sequence of characters로 연속된 문자들의 집합을 의미한다.  

* 파이썬은 유니코드(UTF-8)를 사용한다. 한 문자를 3-4바이트로 나타내는 것을 의미한다. 이 코드 테이블의 일부분이 ASCII 코드이다. 한글은 2바이트를 사용한다.  

* 여러 줄 문자열을 만들려면 \n을 이용하여 줄바꿈을 한다.  

*  문자열 메소드 split()
빈칸으로 구분된 문장이 들어왔을 때 단어로 분리해서 얻어내고 싶을 때 사용하는 함수이다. split()의 결과는 리스트이고 이 항목들을 assign해준다. str.split()의 형태이고 default값은 빈칸으로 구분한다. 구분자를 집어넣으면 구분자별로 분리해준다. 

    ``` python
    msg = "Life is too short"
    w1, w2, w3, w4 = msg.split()
    print(w1) = "Life"
    ```
  
* 문자열을 formatting 하기 위해 %d, %s 등을 이용하여 문자열을 넣고 싶은 자리에 원하는 형식으로 삽입할 수 있다. {}을 이용하여 format()함수를 통해서도 할 수 있다.
    ``` python
    >>> print("The light was {:10}".format('good'))
    The light was good######
    ```  


* 파일 입출력  
    - 파일 열기
        ``` python
        # 스크립트 파일이 존재하는 폴더에 파일이 존재할 때
        fp_r = open("in.txt", 'r')
        fp_w = open("out.txt", 'w')

        # 스크립트 파일이 존재하는 폴더와 다른 폴더에 존재할 때
        fp_r = open("C:\work\in.text", 'r')
        ```  
    - 파일 읽기  

        fp_r은 파일이 어디에 있는지 나타내는 오브젝트를 가리키고 있다. 따라서 다음과 같이 객체에서 정보를 얻을 수 있는 메소드를 사용할 수 있다.  

        ``` python
        fp_r.read() #파일 전체를 하나의 문자열로 읽기
        fp_r.readlines() #파일을 줄 단위로 읽어 각 줄을 문자열로 저장
        fp_r.readline() #파일의 한 줄만을 문자열로 저장한다. 다음 줄을 읽기 위해서는 이 커맨드를 반복해야한다.
        ```  
    - 파일 쓰기  
        ``` python
        fp_w.write(string)
        ```
    - 파일 닫기  
        ``` python
        fp_r = open("in.txt", 'r')
        # 파일 닫기
        fp_r.close()
        # read() 반복문이 종료되면 자동으로 close()를 해주는 with를 사용하는 커맨드는 다음과 같다.
        with fp_r = open("in.txt", 'r')
        '''
        프로그램코드
        ...
        '''
        fp_r.read()
        ```
4. 데이터 구조  
<hr/>  

* 리스트  
리스트가 가진 가장 큰 특징으로는 요소들의 순서가 있다는 것이다. 어떤 값들의 집합을 순서대로 쭉 나열하고 싶을 때 리스트를 사용한다. 우리가 가지고 있는 컴퓨터의 메모리가 일종의 리스트이다. 문자열처럼 인덱싱과 슬라이싱이 가능하다. list() 와 []로 생성할 수 있다. array는 구성 요소가 모두 같은 type이지만 list는 다른 type이어도 상관이 없다.  
    - indexing  
    address는 0부터 시작하여 len(문자열/리스트)-1 을 가진다. 음수 인덱스도 있는데 이는 -len(문자열/리스트)부터 -1까지를 주소로 가진다. (<span style = "color:red">되도록 쓰지 말자</span>)  

    - slicing  
    [start:end:step] 의 형태로 리스트나 문자열 옆애 쓰면 이 조건에 해당하는 것이 슬라이싱된다. 예시는 아래와 같다.

        ``` python
        >>> msg = 'Python' >>> print(msg[1:4:1]) yth
        >>> print(msg[::]) Python
        >>> print(msg[:-4]) Py
        ```  

        palindrome을 찾고 싶을 때 step을 -1을 주어 파악할 수 있다.  

    - 2 dimensianal list  
    리스트 안에 리스트를 element로 가질 수 있기 때문에 이중으로 인덱스를 주어 얻고자 하는 값을 얻을 수 있다.  

    - 리스트 수정하는 방법 중 주의할 점 

        ``` python
        a = [0, 1, 2, 3, 4]
        a[1:2] = [5,6]
        print(a)
        # [0, 5, 6, 2, 3, 4]
        ```
    - 리스트 복사 시 주의할 점  
    레퍼런스로 리스트를 할당해아만 기존의 리스트가 변해도 복사된 리스트가 변하지 않는다. 단순하게 variable을 할당하면 복사된 것이 기존의 것이 변하면 같이 변한다. 

        ``` python
        >>> a = [0,1,2,3,4]
        #리스트a 복사하여 새로운 리스트b 생성
        >>> b= a[:] 
        >>> print(b) [0,1,2,3,4]
        # 비교해 세요 
        >>> c = a a[0] = 10
        >>> print(a) [10,1,2,3,4] 
        >>> print(b) [0,1,2,3,4] 
        >>> print(c) [10,1,2,3,4]
        ```
    - 리스트 연산  

        ``` python
        # +는 리스트들을 연결하여 새로운 리스트를 만든다.
        # *는 리스트를 반복해서 새로운 리스트를 만든다.
        L1 = [1, 3, 5]
        L2 = [2, 4, 6]
        L3 = L1 + L2
        #L3 = [1, 3, 5, 2, 4, 6]
        L4 = L1 * 3
        #L4 = [1, 3, 5, 1, 3, 5, 1, 3, 5]
        ```
    - in 연산자  
    in 연산자를 통해 요소가 리스트 안에 있는지 확인할 수 있다.  

    - 리스트 메소드  
    메소드란 데이터 객체에 대해 어떤 일을 처리할 수 있도록 하는 코드이다. 리스트에서 사용할 수 있는 메소드는 dir("리스트")로 확인할 수 있다. 메소드 목록은 다음과 같다.  

        ``` python
        >>> dir(list)
        ['__add__', '__class__', ...... '__subclasshook__', 'append', 'clear', 'copy', 'count', 'extend', 'index', 'insert', 'pop', 'remove', 'reverse', 'sort'] 
        ```

        이 메소드를 사용하면 결과를 새로운 리스트로 반환하는 것이 아닌 원본 리스트의 내용이 바뀌게 된다.  

        ``` python
        l = [5, 4, 2, 3, 1]
        a = l.sort()
        print(a, l)
        # [1, 2, 3, 4, 5] [1, 2, 3, 4, 5]
        l = [5, 4, 2, 3, 1]
        b = sorted(l)
        print(b, l)
        # [1, 2, 3, 4, 5] [5, 4, 2, 3, 1]
        ```
        - 메소드 .copy()  
        카피하려는 리스트의 내용물을 토대로 새로운 리스트를 만들어 할당하는 것으로 단순하게 변수로 할당하여 복사하는 것과는 다르게 다른 id를 부여받는다. 이것을 shadow copy라고 한다.  

        - 리스트 내장 함수  
        함수는 메소드의 상위 개념으로 어떤 객체에서 정의된 함수를 메소드라고 한다. 역할을 동일하다.  


        * 리스트 생성  
            - list comprehension  
            x in range(10) 을 예로 들면 이는 x가 0 부터 9까지 순서대로 호출되어 사용되는 것이다.  

* 튜플  
튜플은 리스트와 거의 같지만 element들이 고정되어있다는 차이점이 있다. 튜플은 ()로 만들 수 있다. **구성 원소가 하나인 튜플을 만들고 싶을 때 (1) 이렇게 하면 integer로 인식한다. 따라서 이럴 때는 1, 로 표현하여 뒤에 아무런 원소가 없음을 표현해야한다.**  
    - 튜플을 이용한 swap  

        ``` python
        >>> x = 10
        >>> y = 20
        >>> print(x, y) 10 20
        >>> x, y = y, x >>> print(x, y) 20 10
        ```  
    
* 집합(set)  
set()으로 만들 수 있다. duplication을 허락하지 않고 immutable 객체만 원소로 올 수 있다. 변경가능하면 중복되는지를 계속 확인해야하기 때문에 문제가 생길 것이다. 메소드에는 우리가 집합 연산에 사용하는 것들을 모두 사용할 수 있다.(교집합, 차집합, 합집합 등등)  

* 사전(dictionary)  
key:value 쌍을 만들어주는 것이다. key는 immutable 해야하며 중복되지 않은 값이어야 한다.  

6. 조건문과 반복문 
<hr/>  

* 조건문  
일반적인 조건문이란 if 다음에 expression이 온다. 그 아래에 조건을 만족할 시에 실행시킬 코드블럭이 존재한다. python은 Tab으로 구분한다. 조건을 쓸 때 특히 <span style="color:red">같다는 의미의 == 를 주의해서 사용하자. 자주 에러가 발생한다.</span>  

* 반복문  
반복문은 조건문과 거의 동일하지만 반복을 할거냐 말거냐가 조건의 결과로 정해진다. for statement 와 while statement가 있다.  

    - for statement  
    정해진 횟수만큼 반복하는 반복문이다. 형식은 다음과 같다.  
        ``` python
        for i in [....]
        여기서 [...] 은 iterable object가 와야한다.
        ```  
        - continue문은 실행이 되면 반복문 내에 남아있는 뒤의 코드블럭의 실행을 하지 않고 반복문으로 다시 넘어간다.  
        - break 문은 continue문과 다르게 반복문을 그 자리에서 중지시키고 나온다.~~break같은거 많이 쓰지 말자~~
    

    - while statement  
    어떤 조건이 True가 될 때가지 반복하는 반복문이다.

